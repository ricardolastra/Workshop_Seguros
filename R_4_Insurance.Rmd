---
title: "R for Insurance"
date: "Junio del 2019"
output: 
  html_document:
    includes:
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Agenda {.tabset .tabset-fade .tabset-pills}

+ Welcome!
+ Getting Started with R Programming
+ R_Basico_1.0
+ R_Basico_1.1
+ R_Basico_1.2
+ R_dplyr
+ R_ggplot
+ R_Rmd
+ R_Text_minig
+ Bonus
+ Librerías

&nbsp;

### Welcome!

`OBJETIVO:` **Presentación y breve panorama de lo que haremos las próximas semanas**

&nbsp;

Recomendación como en todo, dejen a un lado los paradigmas, cosas que han escuchado, leído en diversos medios, y preparense para tener una mente dispuesta. 

&nbsp;

```{r echo=F, fig.cap="Clear your minds!!!", out.width = '50%'}
knitr::include_graphics("Imagenes/brain.jpg")
```

&nbsp;

Hay que ubicarnos en donde estamos en base a lo que hacemos actualmente. No todo lo que hacemos hoy esta mal, pero hay aún mas cosas que aprender. 

&nbsp;

```{r echo=F, fig.cap="Dónde estamos?", out.width = '60%'}
knitr::include_graphics("Imagenes/Analytics.jpg")
```

&nbsp;

La generación e ingesta de datos hoy es una necesidad, debemos contar con mejores herramientas para el manejo de los mismos. Es muy util en nuestras vidas se consumidores, pero mucho mejor ser generadores y controladores de ellos. 

&nbsp;

```{r echo=F, fig.cap="Datos everywhere!", out.width = '60%'}
knitr::include_graphics("Imagenes/dataUse.jpeg")
```

&nbsp;

Debemos de empezar por algo, los diferentes lenguajes de programación y otras herramientas denominadas Open Source son un excelente comienzo!!

&nbsp;

```{r echo=F, fig.cap="Python y R para empezar", out.width = '60%'}
knitr::include_graphics("Imagenes/poll1.jpeg")
```

&nbsp;

Necesitamos ver el ecosistema, nuestra realidad y tomar la mejor decisión para ver por donde empezamos, todos los lenguajes son utiles, pero no podemos saberlo todo.

&nbsp;

```{r echo=F, fig.cap="Ecosistema de R", out.width = '60%'}
knitr::include_graphics("Imagenes/RWorld.jpeg")
```

&nbsp;

Python y R ya como un mismo lenguaje, es donde vemos el terreno que ha ganado R, Markdown y otras herramientas al apoyarse en un magnífico lenguaje.

&nbsp;

```{r echo=F, fig.cap="R y Python una maravilla!", out.width = '60%'}
knitr::include_graphics("Imagenes/python&R.jpeg")
```

&nbsp;

R es un lenguaje muy usado para la enseñanza, cada vez mas universidades lo usan como herramienta para estadística y otras áreas, chequen este articulo.  http://r4stats.com/articles/popularity/

&nbsp;

Dudas del Open Source, revisen el siguiente Link https://www.gnu.org/licenses/quick-guide-gplv3.html y naveguen.


&nbsp;

### Getting Started with R Programming

`OBJETIVO:` **Breve historia de R y contexto**

&nbsp;

#### Historia de R

&nbsp;

Ross Ihaka and Robert Gentleman desarrollaron `R` como un software *free* cuando impartían clases en la Universidad de Auckland en New Zealand a principios de 1990. 

Lo crearon a partir del lenguaje estadístico denominado `S` y para diferenciar su trabajo usaron una sintaxis similar para su propio uso. En 1993 anunciaron su colaboración en las noticias del mailing list de `S`, muchas personas se interesaron y se sumaron a la colaboración. Dicha colaboración sigue en pie en el sitio https://www.r-project.org/ 

El lanzamiento oficial (1.0.0) fue en Febrero del 2000, para ese entonces ya era parte de la fundación de software libre GNU. Actualmente la última versión (3.6) está disponible desde Abril de este año para más de 30 países.

&nbsp;

#### Ventajas y usos de R

&nbsp;

Es un software que ayuda a la manipulación de datos, cálculos aritméticos y visualización de gráficos dinámicos. 

El código es de fácil escritura y comprensión.

Excelente para el cálculo de matrices, vectores, algoritmos complejos.

Existe una colección muy amplia de herramientas para el análisis de datos, visualización y otros propósitos. `dplyr`, `data.table`,  `tidyr` y `ggplot2` algunos de ellos.

Fácil desarrollo de herramientas con buen nivel de interacción como `blogdown` y `xaringan`.

&nbsp;

#### Iniciando

&nbsp;

Para descargar e instalar `R` en su última versión, deberán utilizar el siguiente link https://cran.r-project.org/bin/windows/base/  donde encontraran la versión para Windows que es el sistema operativo que todos tenemos.

Un lenguaje amigable, fácil de usar y entender, simple y efectivo.

Con `R` se distribuyen algunos paquetes, pero existen muchos más en el sitio CRAN, cubriendo así un amplio espectro de herramientas estadísticas, de cálculo y de visualización que les harán más divertida la vida.

El link con todo el material del curso esta en mi repo personal de Git, tengan cuidado de no aruinarlo, luego hacemos otro curso de Git. https://github.com/ricardolastra/Workshop_Seguros

En los próximos días les hare llegar documentos como estos, los cuales les serán de gran apoyo con cosas básicas, no podemos retener todo en mente, además que no cubriremos muchos comandos, ejemplos y funciones de las paqueterías.


&nbsp;

```{r echo=F, out.width = '50%'}
knitr::include_graphics("Imagenes/cheatsheet.jpeg")
```

&nbsp;

Para las siguientes sesiones usaremos una interface muy "Fancy" denominada RStudio, la cual podrán descargar en el siguiente link https://www.rstudio.com/products/rstudio/download/ que los llevara a tener la versión más reciente 1.2.1335

Existen más programas o UI´s muy padres, Anaconda (luego revisan el siguiente link) https://www.anaconda.com/distribution/ tiene excelentes herramientas con Python y aun para R. Sin embargo una de las mejores herramientas con R es RStudio. 

No nos perdemos de mucho, échenle un ojo.

&nbsp;

```{r echo=F, out.width = '60%'}
knitr::include_graphics("Imagenes/heatmap.jpg")
```

&nbsp;

##### *Están listos?*


### R_Basico_1.0

`OBJETIVO:` **Vistazo de Rstudio y primeros comandos**

&nbsp;

Recordando...

*R es un lenguaje computacional diseñado para la estadística.* 

* Es gratis
* Amplias librerias
* Basto soporte, mailing list, blogs, tutoriales
* De facíl desarrollo
* Desarrolado por estadísticos

&nbsp;

Recuerden que cualquier cosa que escriban en R muy probablemente no seran los primeros en intentarlo, hay una gran posibilidad que alguien ya haya escrito  algun paquete justo para lo que necesitan.

Hecharemos un vistazo a la parte basica de RStudio que nos permitira entender el funcionamiento del lenguaje, sus alcances, sus aplicaciones y sus ventajas sobre las herramientas actuales que conocemos.

&nbsp;

```{r echo=F, out.width = '70%'}
knitr::include_graphics("Imagenes/rstudio.jpg")
```

&nbsp;

Inicien RStudio y abran un R script:

* En Windows click en el boton de Inicio y busquen Rstudio.
* Ya en Rstudio den click en  `File -> New File -> R script` 
* Guardenlo en su carpeta del curso  `File -> Save As -> ruta a su carpeta y nombre del file`

Ahora traten de reproducir las siguientes notas.

Nota. Recuerden el simbolo `#` para comentar su codigo. 
  
&nbsp;

**FORMAS DE DECLARAR Ó GUARDAR Ó ALMACENAR Ó MANTENER VARIABLES:**
```{r }
x = 3
y <- 4
5 -> z
```

**Asi estan almacenadas en el ambiente:**

```{r }
x
y
z
```

Nota. Los valores que guardamos pueden ser usados en subsecuentes operaciones, recuerden que lo mas limpio es poner el nombre a la izquierda y los valores a la derecha.

&nbsp;

**SOBRESCRIBIR VARIABLES:**
```{r }
x = 4
y <- 5
6 -> z
```

**Asi estan almacenadas en el ambiente:**

```{r }
x
y
z
```

**CALCULOS BASICOS:**

Operadores
```{r ,warning=F, error=F, message=F}
#SUMAS
25+25
x+y
#MULTIPLICACIONES
35*2
#DIVISIONES
x/y
#RESTAS
z-x-y
#Potencias
3^2
y^x
```

**CALCULOS BASICOS**

FORMAS DE **NO** HACER CALCULOS BASICOS, ASI NO ES LA SINTAXIS DE R:
```{r ,warning=F, error=F, message=F}
#SUMAS
#=25+25

#MULTIPLICACIONES
#(35)(2)
```

**VECTORES**

```{r }
#Basicos
x <- c(1,4,3,1,3,2,2,2)
x[1]
x[2]
x[2:4]
x[-1]
x[-4]
x[x<=3]
#Función which (más adelante veremos, for, while, ifelse)
#Devuelve la posición del elemento que pidamos validar.
which(x==1)
#Quizá con el alfabeto es más claro.
which(letters == "g")
x==1
#Mas complejos con operaciones, guardamos vectores
Cebollas.huacal <- c(12,4,4,6,9,3)
Chiles.caja <- c(5,3,2,2,12,9)
#Multiplicamos vectores
Cebollas.precio <- Cebollas.huacal *200
Chiles.precio <- Chiles.caja *100
#Sumamos vectores
Cebollas.precio + Chiles.precio
#Tambien lo podemos hacer asi en 1 sola linea
Cebollas.huacal *200 + Chiles.caja *100
```

**OBJETOS**

```{r }
objeto <- 3*3
```

**FUNCIONES**
```{r }
myfun = function(x, y){
  return (x*y)
}
myfun(3,4)

myfun2 = function(x, n=2){
  return(x^n)
}
myfun2(4)
myfun2(2, n=3)
```

**R LOOP´S**

Sintaxis *WHILE*:

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

while (test_expression){
  statement
  }

</div>

&nbsp;

```{r }
i <- 1
while (i < 6) {
  print(i)
  i = i+1
  }
```
&nbsp;

Sintaxis *FOR*:

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

for(var in seq){
  expr
  }

</div>

&nbsp;


```{r }
for (año in c(2014,2015,2016,2017,2018,2019)){
  print(paste("El año actual es", año))
}
```
&nbsp;

Aún mejor...

```{r }
for (año in 2014:2019){
  print(paste("El año actual es", año))
}
```
&nbsp;

lo ideal...

```{r }
años <- c(2014,2015,2016,2017,2018,2019)
for (i in años){
  print(paste("El año actual es", i))
}
```
&nbsp;

**R FUNCTION´S**


Sintaxis *IFELSE*:

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

ifelse(test, yes, no)

</div>

&nbsp;


```{r }
plazo <- c(6,9,12,24,30)
ifelse(plazo==9, "aplica" , "no aplica")
```
&nbsp;

más divertido...

```{r }
plazo <- c(6,9,12,24,30)
ifelse(plazo>=9 & plazo<=24, "aplica" , "no aplica")
```
&nbsp;

Sintaxis *WHICH*:

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

which(x, arr.ind = FALSE, useNames = TRUE)

</div>

&nbsp;


```{r }

which(letters == "g")

```
&nbsp;

Nota. Para más detalles consulten los documentos de apoyo del repo de git en el documento `refcard_2.0_operators_others`

&nbsp;

### R_Basico_1.1

`OBJETIVO:` **Como cargar datos, paquetes y librerias**

&nbsp;


Cargando nuestros datos

R tiene algunas formas de leer archivos, los mas comunes son tablas, archivos planos, archivos con alguna codificacion especifica o estructurada. Aunque no sera el objetivo del curso, leer cadenas de texto, datos sin estructuras definidas o espcificas y archivos sin algun tipo de orden, es algo que tambien se puede hacer en R. 

Para leer datos de un archivo, primero deben saber que tipo de archivo es, es decir, su extension. La tabla de abajo muestra una lista de funciones que pueden ser importadas segun el formato del archivo.

  tipo de datos                 funcion         paquete 
  ------------------------- ---------------  --------
  comma separated (.csv)    `read_csv()`     readr
  other delimited formats   `read_delim()`   readr
  R (.Rds)                  `read_rds()`     readr
  Stata (.dta)              `read_dta()`     haven   
  SPSS (.sav)               `read_spss()`    haven   
  SAS (.sas7bdat)           `read_sas()`     haven   
  Excel (.xls, .xlsx)       `read_excel()`   readxl  
  regular delimited files   `fread()`        data.table 


Nota. Mas información ver documento de apoyo `data-import`

&nbsp;

Paqueterias de R ó los famosos *packages*

Los paquetes de R pueden ser instalados desde el famoso CRAN, el cual es una red de archivos de alta gama. Para ello deberán  usar la función `install.packages`. Cuando instalan un paquete ponen una copia en la computadora de forma local, pero aun no lo hace "usable", solo esta "disponible". Para usarlo deberan adjuntar o cargar la funcion de `library`.

Gracias a nuestro amigo Hadley y otros colaboradores, en este curso usaremos para prueba de carga el famoso "the tidyverse". `Tidyverse` nos brinda grandes herramientas para manipulación basica y avanzada de datos, es muy funcional, facíl e intuitiva. 

&nbsp;

```{r, eval=FALSE}
install.packages("tidyverse")
```
```{r}
library(tidyverse)
```

&nbsp;

Nota. Ayuda en  R

Podemos usar la función `help` o el operador al inicio de cada sentencia `?`.

```{r}
#help(help)
#?str
```

&nbsp;

Cargando nuestro primer archivo:

```{r}
read_csv("bases/PRIMAS_EJE_CARGA.csv")
```

UPS!! Problemas!!!

&nbsp;

Hagamos que este disponible la libreria...

```{r}
library(readr)
read_csv("bases/PRIMAS_EJE_CARGA.csv")
```

Clasico de SIISA y nuestros amigos de TI!!!

&nbsp;

```{r}
library(readr)
read_csv("bases/PRIMAS_EJE_CARGA.csv", skip = 2)
```

&nbsp;

```{r}
primas <- read_csv("bases/PRIMAS_EJE_CARGA.csv", skip = 2, n_max = 5)
```

&nbsp;

```{r}
#install.packages("data.table")
library(data.table)
primas_fread <- fread("bases/PRIMAS_EJE_CARGA.csv", skip = 2, sep = ",")
head(primas_fread,5)
```

&nbsp;

Ahora validamos ó exploramos los datos que cargamos en el ambiente con las siguientes funciones estadísticas

```{r}
class(primas_fread)
```

&nbsp;

Podemos obtener aún más

```{r}
library(dplyr)
glimpse(primas_fread)
```

&nbsp;

Un poco más

```{r}
str(primas_fread)
```

&nbsp;

la mejor información!!!

```{r}
summary(primas_fread)
```

### R_Basico_1.2

`OBJETIVO:` **Manejo de datos**

&nbsp;

Normalmente los datos en R son almacenados como `data.frame`

Un data.frame es una lista de vectores de la misma longitud, piensenlos como una tabla de observaciones (individuos), cada entrada del vector en la lista forma una columna, cada columna puede ser de diferente tipo, conocemos a las columnas como variables y a las filas como observaciones.

Un data.frame tiene entonces dos dimensiones correspondientes al numero de filas y columnas, en ese estricto orden. 

Empezaremos a hacer nuestros primeros subsets, muy utiles en la vida real.

&nbsp;

Empezamos con un clasico, `filter`

```{r}
filter(primas_fread, PLAZO == 34 & SEXO == "F")
```



```{r}
filter(primas_fread, PLAZO == 3, NOMBRE %in% c("AARON", "RICARDO"))
```

&nbsp;

Buen acceso a ciertas observaciones, `slice`

```{r}
slice(primas_fread, 1:5)
```
Que pasó aqui?

```{r}
head(slice(primas_fread,-c(1,2)))
```
Revisemos con un `head` y un `tail`

```{r}
head(primas_fread)
```
```{r}
tail(primas_fread)
```

&nbsp;

Entonces `slice` y `filter` se usan para extraer algun tipo de "observación, row, fila, value, entrada, etc.", de la misma forma usamos `select` para acceder a las columnas.



```{r}
select(slice(primas_fread, 23340:23345), c(PATERNO, MATERNO, NOMBRE))
```

...podemos usar algo super util como el simbolo de `$`, el cual nos ayudara a acceder a una columna especifica de un df


```{r}
sd(primas_fread$PRIMA)
```
o tambien...
 
```{r}
mean(primas_fread$PRIMA)
```
&nbsp;

> Ejercicio 1

El objetivo del siguiente ejericio es para que practiquen, algunas cosas que hemos aprendido, traten de hacerlo siguiendo las notas, recuerden que deben de tener instalado y cargado el `tidyverse`.

Usen el archivo que esta en la carpeta de las [bases](https://github.com/ricardolastra/Workshop_Seguros/tree/master/bases) de mi repo denominado `PRIMAS_EJE_AUTOS.csv`.

&nbsp;

  a) Lean la base del ejericio con alguna función de la libreria `readr`,  y limiten la lectura a 20 rows.

```{r}
library(readr)
read_csv("C:/Users/Administrador/Desktop/DOC/WORKSHOP_R/Workshop_Seguros/bases/PRIMAS_EJE_AUTOS.csv", n_max = 20)
```

&nbsp;

  b) Lean TODA la base del ejericio y asignen la información a una variable, traten de quitar el encabezado feo de los reportes de SIISA. 


```{r}
library(readr)
test <- read_csv("C:/Users/Administrador/Desktop/DOC/WORKSHOP_R/Workshop_Seguros/bases/PRIMAS_EJE_AUTOS.csv", skip = 3)
```
&nbsp;

  c) Ahora, con su variable, usen por lo menos dos de las funciones para exploración de datos.

```{r}
summary(test)
```

```{r}
str(test)
```

&nbsp;

### R_dplyr

`OBJETIVO:` **Pipes, datos en forma tidy y vervos de la librería**

&nbsp;

Sigan cuidadosamente las siguientes instrucciones, inicien RStudio y generen un nuevo proyecto:

* En Windows click en el botón de Inicio y busquen Rstudio.
* Ya en Rstudio den click en  `File -> New Project... -> Existing Directory -> Browse... -> seleccionar carpeta destino -> Open -> Create Project` 
* Ya que se abre otra pantalla de R click en  `File -> New File -> R script` 
* Guárdenlo  en su carpeta del Proyecto nuevo que acabamos de crear.  `File -> Save As -> ruta a su carpeta y nombre del file`
* Iniciemos con lo siguiente:

&nbsp;

```{r}
library(dplyr)
library(readr)
emision <- read.csv(list.files(pattern='EMISION'), header = T, skip = 2, stringsAsFactors=F)
```
Revisamos los datos:

```{r}
str(emision)
```
&nbsp;

**Verbos de `dplyr` que usaremos:**

* mutate() adds new variables that are functions of existing variables
* select() picks variables based on their names.
* filter() picks cases based on their values.
* summarise() reduces multiple values down to a single summary.
* arrange() changes the ordering of the rows.

Provided by https://dplyr.tidyverse.org/


&nbsp;

```{r}
emision_modificado <- emision %>%
  mutate(POL_COMPL = paste(Sucursal, Producto, Poliza, sep = "-"))
```
&nbsp;

```{r, eval=FALSE}
str(emision_modificado)
```
&nbsp;

```{r}
#Primeros 4 digitos de un valor
emision_modificado <- emision_modificado %>%
  mutate(Año_cont = sub("^(\\d{4}).*$", "\\1", Fecha.Cont))
#Ultimos 4 digitos de un valor
#sub(".*(\\d+{4}).*$", "\\1", df)
```
&nbsp;

```{r, eval=FALSE}
str(emision_modificado)
```

&nbsp;

```{r}
emision_modificado <- emision_modificado %>%
  select(-(c(Contrato,Fondo.Especia,Clave.Vehiculo.Santander)))
```

&nbsp;

```{r}
colnames(emision_modificado)
```

&nbsp;

No guardamos lo siguiente en la variable, solo observen que pasa.

```{r}
emision_modificado %>%
  select(ends_with("conductor")) %>%
  head()
```

&nbsp;

```{r}
emision_modificado <- emision_modificado %>%
  filter(Año_cont == "2018", Marca %in% c("MINI","Ferrari"))
```
&nbsp;

```{r, eval=FALSE}
head(emision_modificado)
```
&nbsp;

```{r}
emision_modificado <- emision_modificado %>%
  group_by(Desc.de.Agente) %>%
  summarise(cuenta = n())
```


&nbsp;


```{r}
emision_modificado
```
&nbsp;

```{r}
emision_modificado %>%
  arrange(desc(cuenta))
```
```{r}
emision_modificado <- emision_modificado %>%
  arrange(cuenta)
```

&nbsp;


```{r}
emision_modificado
```
&nbsp;

**...y la magia de `dplyr` es:          un solo PIPE!!!!!**

&nbsp;

```{r}
emision %>%
  mutate(POL_COMPL = paste(Sucursal, Producto, Poliza, sep = "-")) %>%
  mutate(Año_cont = sub("^(\\d{4}).*$", "\\1", Fecha.Cont)) %>%
  select(-(c(Contrato,Fondo.Especia,Clave.Vehiculo.Santander))) %>%
  filter(Año_cont == "2018", Marca %in% c("MINI","Ferrari")) %>%
  group_by(Desc.de.Agente, Marca) %>%
  summarise(cuenta = n()) %>%
  arrange(cuenta)
```

&nbsp;

Lo guardan en su variable y listo!!!

```{r}
emision_modificado <- emision %>%
  mutate(POL_COMPL = paste(Sucursal, Producto, Poliza, sep = "-")) %>%
  mutate(Año_cont = sub("^(\\d{4}).*$", "\\1", Fecha.Cont)) %>%
  select(-(c(Contrato,Fondo.Especia,Clave.Vehiculo.Santander))) %>%
  filter(Año_cont == "2018", Marca %in% c("MINI","Ferrari")) %>%
  group_by(Desc.de.Agente, Marca) %>%
  summarise(cuenta = n()) %>%
  arrange(cuenta)
```

&nbsp;

Aplausos!!!

Extra. Un link muy bueno para "regex"  https://www.rexegg.com/regex-quickstart.html 

Y tambien este super bien explicado https://dev.to/emmawedekind/regex-cheat-sheet-2j2a

### R_ggplot

`OBJETIVO:` **Graficar entendiendo los datos, escalas y tipos de gráficos, mejorar visualizaciones actuales**

&nbsp;

Empezamos usando los datos de la ultima sesión.

```{r}
library(dplyr)
library(readr)
emision <- read.csv(list.files(pattern='EMISION'), header = T, skip = 2, stringsAsFactors=F)
```
Revisamos los datos:

```{r, eval=FALSE}
str(emision)
```

Si pudieron cargar `tidyverse` solo habiliten la libreria.

```{r}
library(ggplot2)
```

Si *NO* pudieron cargar `tidyverse`, descarguen `ggplot2`

```{r, eval=FALSE}
install.packages("ggplot2")
library(ggplot2)
```

&nbsp;

Ventajas de `ggplot2`:

 + Muy flexible
 + Fácil de interpretar, sintaxis sencilla
 + Sistema ya muy avanzado para graficar
 + Ecosistema amplio
 + Comunidad amplia, gran soporte
 + Basado en el libro "The Grammar of Graphics"

&nbsp;

¿Cómo se usa?

Empezamos con la función ggplot(), integrando nuestra base y sus variables (con aes()). Luego agregamos las coordenadas o puntos a graficar con geom_point() o con  geom_histogram(), luego las escalas ó colores (como puede ser scale_colour_brewer()), algunas especificaciones como  facet_wrap() y hasta títulos o marcas.

&nbsp;

¿Y si graficamos con R base?  `ggplot2` VS R base de una manera muy sencilla.

```{r}
hist(emision$Agte.UDI.2)
```

Y con `ggplot2` se ve lo mismo de la siguiente forma:

```{r , warning=F, error=F, message=F}
ggplot(emision, aes(x = Agte.UDI.2)) +
  geom_histogram()
```
&nbsp;

Aesthetic Mapping

En el mundo de `ggplot2` *aesthetic* significa "algo que puedes ver". Puedes incluir las siguientes opciones:

-   position (por ejemplo en el eje x o en el eje de las y´s)
-   color (el color de relleno)
-   fill (el color del grafico)
-   shape (forma)
-   linetype
-   size (tamaño)

Cada tipo de gráfico solo acepta un conjunto de datos, es natural de una gráfica de dos dimensiones.

&nbsp;

Objetos geométricos (`geom`)

Son los tipos de gráficos que tenemos en cada imagen:

-   Puntos (`geom_point`, para scatter plots, dot plots, etc.)
-   Lineas (`geom_line`, para time series, trend lines, etc.)
-   Diagrama de caja y brazo (`geom_boxplot`)

Un gráfico al menos debe tener un objeto geométrico, y pueden ir agregando más con el símbolo +, que al ponerlo lo identa de manera correcta.

Puedes tener una buena ayuda con los objetos disponibles de la siguiente forma:

```{r, eval=FALSE}
help.search("geom_", package = "ggplot2")
```

&nbsp;

Un regalo...!

```{r , warning=F, error=F, message=F}
emision <- emision %>%
  mutate(Prima.Emitida= as.numeric(sub(",", "", Prima.Emitida, fixed=TRUE))) %>%
  filter(Fecha.Cont<201813 & Fecha.Cont>201800)
```
Revisamos lo que pasó....

```{r , warning=F, error=F, message=F}
emision %>%
  mutate(Prima.Emitida= as.numeric(sub(",", "", Prima.Emitida, fixed=TRUE))) %>%
  group_by(Fecha.Cont) %>%
  summarise(Prima_E = sum(Prima.Emitida))
```
Y graficamos...

```{r , warning=F, error=F, message=F}
ggplot(emision, aes(y = Prima.Emitida, x = Fecha.Cont)) +
  geom_point()
```
```{r , warning=F, error=F, message=F}
ggplot(emision, aes(y = Prima.Emitida, x = Fecha.Cont)) +
  geom_point() +
  scale_x_continuous(limits = c(201801, 201812))+
  ylab("Prima Emitida")+
  xlab("Mes contable")
```

O queremos esto:

```{r , warning=F, error=F, message=F}
emision_resumen <- emision %>%
  mutate(Prima.Emitida= as.numeric(sub(",", "", Prima.Emitida, fixed=TRUE))) %>%
  group_by(Fecha.Cont) %>%
  summarise(Prima_E = sum(Prima.Emitida))
```

Y se ve mejor asi:

```{r , warning=F, error=F, message=F}
ggplot(emision_resumen, aes(y = Prima_E, x = Fecha.Cont)) +
  geom_point() +
  scale_x_continuous(limits = c(201801, 201812))+
  ylab("Prima Emitida")+
  xlab("Mes contable")
```

Le subimos el volumen... otro regalo!!!

```{r , warning=F, error=F, message=F}
#Una regresion lineal sencilla
emision$pred.SC <- predict(lm(Prima.Emitida ~ log(Fecha.Cont), data = emision))
#Subset
emision_predic <- emision %>%
  mutate(Prima.Emitida= as.numeric(sub(",", "", Prima.Emitida, fixed=TRUE))) %>%
  group_by(Fecha.Cont) %>%
  summarise(Prima_E = sum(Prima.Emitida),
            Prima_predic= sum(pred.SC))
#De mejor interpretación
p1 <- ggplot(emision_predic, aes(x = log(Fecha.Cont), y = Prima_E))

p1 + geom_point() +
  geom_line(aes(y = Prima_predic))
```

Agregamos una sombra de bandas de confianza....

```{r , warning=F, error=F, message=F}
p1 + geom_point() +
  geom_line(aes(y = Prima_predic))+
  geom_smooth()
```
&nbsp;

Extra. Revisando los colores...


```{r , warning=F, error=F, message=F}
emision_resumen <- emision %>%
  mutate(Prima.Emitida= as.numeric(sub(",", "", Prima.Emitida, fixed=TRUE)),
         Prima.Pagada= as.numeric(sub(",", "", Prima.Pagada, fixed=TRUE))) %>%
  group_by(Fecha.Cont,Marca,Desc..Grupo) %>%
  filter(grepl('G|R|F|Mini', Desc..Grupo)) %>%
  summarise(Prima_E = sum(Prima.Emitida),
            Prima_P = sum(Prima.Pagada))
#Colores con "colour" rellena con una 3ra variable relacionada a las Y´s directamente
ggplot(emision_resumen, aes(x = log(Fecha.Cont), y = Prima_E, colour = Marca))+
  geom_point()
```

&nbsp;

Nice!!!


```{r, eval=FALSE}
install.packages("ggthemes")
```

```{r , warning=F, error=F, message=F}
## Temas extra para mejorar la parte visual
library(ggthemes)
ggplot(emision_resumen, mapping = aes(x = log(Fecha.Cont), y = Prima_E)) + geom_point(aes(size=Prima_P, color=Marca)) + 
  geom_text(aes(label=Desc..Grupo, vjust=-1.0, hjust=0, alpha=0.5)) +
  guides(fill=FALSE, alpha=FALSE, color=FALSE) + 
  labs(x = 'Fecha Contable (Escala Logaritmica)', y = 'Primas emitidas', size='Prima Pagada' ) + theme_hc()
```
&nbsp;

### R_Rmd

`OBJETIVO:` **Crear, guardar, ejecutar codigo en un reporte**

> RMD/R Markdown

La creación de documentos con Markdown R comienza con un archivo de extensión .Rmd, el cual contiene una combinación de markdown (contenido con formato de texto simple) y trozos de código R. El archivo .Rmd se alimenta a `knitr`, que ejecuta todos los trozos de código R y crea un nuevo documento de reducción (.md) que incluye el código R y su salida.

Ventajas respecto a otras herramientas de reportes:

  1. Tiene gran diversidad de formatos de salida, como html, pdf, bookdown, latex-pdf, slide, dashboard, folletos, entre otros.
  2. Reproducible
  3. Se puede ejecutar en tiempo real
  4. Excelente framework para ciencia de datos
  5. Se generan reportes de alta calidad que pueden ser compartidos en grandes audiencias
  
&nbsp;

Iniciamos

```{r, eval=FALSE}
install.packages("rmarkdown")
library(rmarkdown)
```

Para efectos practicos seguiremos el siguiente tutorial que nuestros amigos de Rstudio ya hicierón.

&nbsp;

https://rmarkdown.rstudio.com/lesson-1.html

(Seguimos lo más que se pueda esas notas, si no terminamos lo hacen en un rato libre, vale la pena!!!)

&nbsp;

También instalamos lo siguiente para probar las ultimas maravillas que se pueden hacer en un RMD:

```{r, eval=FALSE}
install.packages("reticulate")
library(reticulate)
```

para correr chunks de Python como sigue:


```{python}
x = "Hello World!"
print(x)
```

&nbsp;


> Ejercicio 2

Usando la base de emision de la sesión 6. (pueden volver a cargar la base emision como yo lo hice o como ustedes crean conveniente.)

1.  Calcula el total de primas emitidas
```{r}
library(readr)
library(dplyr)
emision <- read.csv(list.files(pattern='EMISION'), header = T, skip = 2, stringsAsFactors=F)
emision <- emision %>%
  mutate(Prima.Emitida= as.numeric(sub(",", "", Prima.Emitida, fixed=TRUE)),Prima.Pagada= as.numeric(sub(",", "", Prima.Pagada, fixed=TRUE)))
sum(emision$Prima.Emitida)
```
2.  Filtra la base para sacar solo la prima de los autos MINI
```{r}
emision %>%
  filter(Marca=="MINI") %>%
  summarise(Prima.Emitida = sum(Prima.Emitida))
```
3.  Agrupa y summariza el total de MINI por prima emitida y prima pagada, recuerda convertir a numero como el "regalo"
```{r}
emi_grafica <- emision %>%
  filter(Marca=="MINI") %>%
  group_by(Fecha.Cont) %>%
  summarise(Prima.Emitida = sum(Prima.Emitida),Prima.Pagada = sum(Prima.Pagada))

emi_grafica
```
4.  Del resumen anterior, haz una grafica lo mejor que puedas, que si diga algo visualmente!!!
```{r , fig.width= 8, fig.height=5, fig.align="center"}
library(ggplot2)
ggplot(emi_grafica, aes(Fecha.Cont,Prima.Emitida)) +
  geom_point(size=4, color="red") +
  geom_line()
```

Todo lo anterior en un RMD con tus datos!

- Lo envian por mail hasta el Miercoles 26 a las 11:59:00 p.m.

&nbsp;

### R_Text_minig

`OBJETIVO:` **Minar, explorar, limpiar, visualizar, diseñar y construir modelos**

&nbsp;

Pueden ir descargando e instalando librerias!

```{r, echo=T, warning=F, error=F, message=F}
#install.packages("tm")
#install.packages("qdap")
#install.packages("wordcloud")
library(tm)
#library(qdap)
library(wordcloud)
```

En una carpeta ponemos algunos libros, en este caso 2 versiones de la Biblia ed 1602 y 1909

```{r }
biblia_corpus <- VCorpus(DirSource("C:/Users/Administrador/Desktop/DOC/WORKSHOP_R/Workshop_Seguros/Texto", encoding = "UTF-8"),readerControl = list(language = "es-419"))
inspect(biblia_corpus[1:2])
```
Generamos una función que limpia nuestro texto, ojo, `replace_abbreviation` del paquete `qdap` yo no lo puedo instalar por falta de version de Java en 32 bit, que es la configuración actual de mi `R`, a muchos si les va a jalar.

```{r }
#Función de funciones de r base y tm

clean_corpus <- function(corpus){
  corpus <- tm_map(corpus, stripWhitespace)
  corpus <- tm_map(corpus, removePunctuation)
  corpus <- tm_map(corpus, content_transformer(tolower))
  #corpus <- tm_map(corpus, content_transformer(replace_abbreviation))
  corpus <- tm_map(corpus, removeNumbers)
  corpus <- tm_map(corpus, removeWords, c(stopwords("en"), "que"
                                          ,"los", "por","porque", "mas", "del", "the", "las", "para", 
                                          "con", "como", "entonces", "project", "and", "you", "sus",
                                          "también", "todo", "les", "ellos", "this", "with", "había",
                                          "todos", "tambien", "šus","vosotros", "gutenbergtm", "fue",
                                          "dicho", "una", "uno", "entre", "este", "esto", "diziendo", "gutenberg"))
  return(corpus)
}
```

... y limpiamos!

```{r }
biblia_corpus <- clean_corpus(biblia_corpus)
```

&nbsp;


#### Qué hace cada función?

R base y tm:
  
tolower(): Pasamos todo a minúsculas (Cuidado si se buscan nombre propios) (R base)
removePunctuation(): Elimina puntuación (paquete tm)
removeNumbers(): Elimina numeros  (cuidado si se buscan cantindades) (paquete tm)
stripWhitespace(): Quita espacios extra (paquete tm)
removeWords(): Elimina palabras, muy útil combinarla con stopwords() (paquete tm)

Paquete qdap:
  
bracketX(): Elimina lo que esté entre paréntesis.
replace_number(): Pasa los numeros a palabras (por ejemplo. «2» pasa a «two», tener en cuenta que el ejemplo se utiliza ingles)
replace_abbreviation(): camba abreviaciones por la versión completa  (por ejemplo «Sr» pasa a «Senior»)
replace_contraction(): Elimina contracciones (por ejemplo «can’t» pasa «can not»)
replace_symbol() Pasa símbolos a palabras (por ejemplo «@» pasa a «at»)

De la función para limpiar el corpus de arriba quizá lo mas interesante a destacar es eliminar las palabras comunes con removeWords(). Algunas líneas más adelante veremos la importancia de limpiar términos que no aportan información útil.

Vamos a obtener la frecuencia con la que aparecen los términos en la colección de documentos que tenemos, para ellos seguiremos los siguientes pasos:
  
  1. Creamos una matriz de términos por documentos con TermDocumentMatrix() de tm.
  2. La transformamos en matriz as.matrix.
  3. Sumamos por filas para obtener el número de veces que aparece cada término.
  4. Creamos una matriz de términos por documento, (Term-Document Matrix).

Matriz por términos de documentos

```{r }
biblia_tdm <- TermDocumentMatrix(biblia_corpus)
inspect(biblia_tdm)
```
Convertimos

```{r }
biblia_m <- as.matrix(biblia_tdm)
head(biblia_m)
```
Sumamos las filas de cada versión de libro

```{r }
biblia_words <- sort(rowSums(biblia_m), decreasing = T) 
head(biblia_words)
```
Obtenemos matriz de frecuencias por palabra

```{r }
biblia_freq <- data.frame(terms = names(biblia_words), num = biblia_words)
head(biblia_freq) 
```
Hacemos nuestra fantastica imagen!

```{r }
wordcloud(biblia_freq$terms, biblia_freq$num, max.words = 75, colors = c( "grey", "orange", "red"))  
```
&nbsp;

#### Algoritmos de Texto

Comentamos que construiríamos  modelos, para ellos existen algoritmos de texto muy poderosos, aquí uno muy bueno, *from scratch*, el famoso "Word2vec" usado en NLP:  https://gist.github.com/primaryobjects/8038d345aae48ae48988906b0525d175

Sin embargo ya hay implementaciones buenísimas, con varios algoritmos y es oficial de `R`.

https://cran.r-project.org/web/packages/stringdist/index.html

&nbsp;

De nuestra matriz `biblia_freq`, seleccionamos las palabras con una frecuencia mayor a 50:

```{r }
biblia_freq2 <- biblia_freq %>%
  filter(num>50) 
```
Cargamos super libreria llena de algoritmos...

```{r, echo=T, warning=F, error=F, message=F }
#install.packages("stringdist")
library(stringdist)
```
Obtenemos palabras unicas con mayor frecuencia y pasamos algoritmo `Jaro-Winkler` ó distancia winkler.

Nota.La libreria tiene algoritmos como el de `Levenstein`, `Jaccard`, `qgram`, `coseno`, entre otros.

```{r }
uniquewords <- unique(as.character(biblia_freq2$terms))
distancewords <- stringdistmatrix(uniquewords,uniquewords,method = "jw")
```

Pasamos en un cluster de 20 grupos todas las palabras y generamos un dendograma con la funcion `hclust`

```{r, fig.width= 10, fig.height=5, fig.align="center"}
#Pasamos lista de unicas palabras
rownames(distancewords) <- uniquewords
#Graficamos por cluster
hc <- hclust(as.dist(distancewords))
plot(hc)
rect.hclust(hc,k=20)
```

&nbsp;

No se olviden de leer esto para los interesados en texto, y si, es real el link!!! y si es el tidyverse para texto!!! Awsome!!!

https://www.tidytextmining.com/tidytext.html

20 minutos para un buen tutorial de REGEX

https://tutorialzine.com/2014/12/learn-regular-expressions-in-20-minutes


Herramienta para probar y depurar expresiones regulares.

https://regex101.com/

&nbsp;

### Bonus

`OBJETIVO:` **Hacer presentes algunos temas de los muchos que existen en el universo de R y los datos**

&nbsp;

####  A. Strings

Los *strings* son cualquier valor que se encuentre entre comillas ó comillas sencillas. A estos valores `R` los trata como *strings*, se almacenan entre comillas aunque en la UI solo se vean comillas sencillas.


```{r , warning=F, error=F, message=F}   
a <- 'Empieza y termina con comilla sencilla'
a

b <- "Empieza y termina con comillas"
b

c <- "Comilla sencilla ' en medio de comillas"
c

d <- 'Comillas " en medio de comilla sencilla al inicio y al final'
d
```

Ejemplo de *strings* invalidos:

```{r , eval=F} 
e <- 'Comillas mezcladas" 
Resultado:
INCOMPLETE_STRING
```
```{r , eval=F} 
f <- 'Una comilla sencilla ' dentro de otras comillas sencillas'
Resultado:
INCOMPLETE_STRING
```
```{r , eval=F} 
g <- "Comillas " dentro de comillas dobles"
Resultado:
INCOMPLETE_STRING
```

Para concatenar strings usamos algo muy sencillo `paste`

```{r } 
a <- "D00"
b <- '1234'
c <- "2019 1"

print(paste(a,b,c))

print(paste(a,b,c, sep = "-"))

print(paste(a,b,c, sep = "", collapse = ""))
```
Para formatear los strings también usamos algo sencillo:

```{r } 
# Justificar a la Izquierda
cadena <- format("Cuota", width = 6, justify = "l")
cadena

# Justificar al centro
cadena <- format("Cuota", width = 9, justify = "c")
cadena
```
Podemos contar los caracteres de una oración con `nchar()`

```{r } 
cadena2 <- nchar("Prima Emitida en $ usd...")
cadena2
```
Podemos cambiar a mayúsculas o minúsculas.
```{r } 
toupper(cadena)
```
```{r } 
tolower(cadena)
```
Por ultimo podemos hacer substrings más cortos de uno ya existente

```{r }
# Extraer caracteres de la 5ta a la  7th posición
cadena3 <- substring("Ricardo Lastra", 5, 7)
cadena3
```

Adicional a R base pueden revisar la libreria `stringr` cuya sintaxis es muy amigable, esta dentro del universo Tidy que ya conocemos. 

Pueden consultar el siguiente link https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html


  
####  B. Fechas
  
  Son de las cosas que más dolores de cabeza les dan a algunos, sin embargo hay librerías que lo hacen sencillo, las fechas son difíciles de manejar por los formatos en los que cada sistema las almacena, este no depende de los sistemas, sino de la necesidad del usuario, de la zona horaria, y en algunos casos son solo días, meses o horas con minutos y segundos los que se necesitan.  
  
  Una magnifica libreria es `lubridate` la cual soporta instantes, intervalos, duraciones y periodos.
  
```{r , warning=F, error=F, message=F}  
fecha <- Sys.Date()
fechas <- seq(fecha, length.out=12, by = "1 month")
fechas
```
&nbsp;

más ejemplos...

Accedemos al formato `dd/mm/aaaa` con la funcion **dmy** y obtenemos el mes de la fecha de nacimiento:

```{r , warning=F, error=F, message=F}
library(lubridate)
bday <- dmy("29/05/1986")
month(bday)
```

Accedemos al día de la semana de ese año:

```{r , warning=F, error=F, message=F}
wday(bday, label = TRUE)
```

Y accedemos también al dia del año actual:

```{r , warning=F, error=F, message=F}
year(bday) <- 2019
wday(bday, label = TRUE)
```
&nbsp;

Y en formato `aaaa/mm/dd hr:min:seg` con la funcion **ymd_hms** y obtenemos el mes de la fecha de esta forma:

&nbsp;

```{r , warning=F, error=F, message=F}
time <- ymd_hms("2019-06-25 15:30:30")
time
```
Funciones de ayuda para manipular time zones: with_tz(), force_tz()

```{r , warning=F, error=F, message=F}
# Changes printing
with_tz(time, "America/Chicago")
```

```{r , warning=F, error=F, message=F}
# Changes time
force_tz(time, "America/Chicago")
```

####  C. Factores
  
  Cuando uno quiere analizar datos, regularmente necesita variables que funcionan como etiquetas. Estas etiquetas pueden ser contadas, pero no sumadas. A este tipo de variables se les conoce como variables categóricas y en R se llaman factores.

```{r , warning=F, error=F, message=F}  
mascotas <- c("P", "G", "P", "P", "G", "P")
mascotas <- factor(mascotas)
mascotas
```

```{r , warning=F, error=F, message=F}  
mascotas <- factor(c("P", "G", "P", "P", "G", "P","G"), levels=c("G", "P"), labels=c("GATO", "PERRO"))
mascotas
```  
####  D. Paleta de colores
  
  En el mundo visual, para tunnear nuestros graficos, la libreria "RColorBrewer" es una herramienta basica, contiene

```{r , warning=F, error=F, message=F}
#install.packages("RcolorBrewer")
library(RColorBrewer)
#create a sequential palette for usage and show colors
mypalette<-brewer.pal(7,"Greens")
image(1:7,1,as.matrix(1:7),col=mypalette,xlab="Tonos de Verde",
       ylab="",xaxt="n",yaxt="n",bty="n")
```  
```{r , warning=F, error=F, message=F}
## display a qualitative palette
display.brewer.pal(7,"Accent")
``` 

Mas información en: https://www.rdocumentation.org/packages/RColorBrewer/versions/1.1-2/topics/RColorBrewer

####  E. Listas
  
Algo muy util en programación orientada a objetos son las listas, son parecidas a los vectores, pero con una diferencia importante: pueden tener los elementos de diferentes tipos.

```{r , warning=F, error=F, message=F}
lista <- list(1, 2, 3, 4, 5)
lista
```
&nbsp;

El operador de extracción ([), devuelve una lista

&nbsp;

```{r , warning=F, error=F, message=F}
lista[1]
```

```{r , warning=F, error=F, message=F}
is.list(lista[1])
```

```{r , warning=F, error=F, message=F}
is.vector(lista[1])
```
&nbsp;

El operador [[ devuelve un vector

```{r , warning=F, error=F, message=F}
lista[[1]]
```

```{r , warning=F, error=F, message=F}
is.list(lista[[1]])
```

```{r , warning=F, error=F, message=F}
is.vector(lista[[1]])
```

&nbsp;

Asi es como se ven los diferentes datos de 

```{r , warning=F, error=F, message=F}
renta <- list(direccion="Masarik 306", m2=c(10, 15, 3), dlls.men=2500)
renta
```
&nbsp;

Existe otro operador de acceso: $

&nbsp;

```{r , warning=F, error=F, message=F}
renta$dlls.men
```


```{r , warning=F, error=F, message=F}
renta[3]
```


```{r , warning=F, error=F, message=F}
renta[[2]]
```

&nbsp;
  
####  F. tidyr
  
Otro tema muy importante para la manipulación y manejo de datos son formatos denominados *tidy*, es una abstracción de datos limpios, antes del concepto ya existian datos almacenados de esta forma, pero `R` nos brinda una serie de verbos ó funciones para convertirlos como queremos de una manera simple y sencilla.

Mas info revisen el siguiente artículo:

+ [Artículo Tidy Hadley Wickham](http://vita.had.co.nz/papers/tidy-data.pdf)

Asi los queremos:

![Tidy Data](http://r4ds.had.co.nz/images/tidy-1.png)
  
Se acomoda cada *variable* en una *columna*

Cada *observación* en un *renglón*

Y cada *valor* en una *celda* ó *casilla*.

  + Fuente: [Presentaciones de Hadley Wickham](http://vita.had.co.nz/papers/tidy-data-pres.pdf)
  
&nbsp;

*¿Cómo podemos encontrar la información almacenada en el mundo de los datos?*

Aquí algunos ejemplos:

Table: Observación con datos implícitos

||Lat|Long|Indicador|
|:----:|:------:|:-------:|:--------:|
|Obs1| \# | \# | \# | 


Table: Con fecha implícita

| | lugar | indicador |
|:---:|:-----:|:-----:|
|Obs 1 |  | |
|Obs 2 | |  |


Table: Otro con Fecha implícita 

| |Fecha 1 | Fecha 2 |
|:---:|:-----:|:------:|
|lugar 1|    |   |
|lugar 2|  | |

Table: Uno más!!!

|  |  Fecha 1 | Fecha 2 | ... |
|:-----:|:-------:|:-------:|:------:|
| **LUGAR 1** |   |    |   |  |
| Ind 1 |   #  | #   | ... |
| Ind 2 |   #  |  #   | ... |
| **LUGAR 2** |   |    |   |  |
| Ind 1 |   #  | #   | ... |
| Ind 2 |   #  |  #   | ... |

Tablas que también existen en otro tipo de formatos: 

||Indicador 1|Indicador 2|
|:--:|:--:|:---:|

||Fecha 1| Fecha 2| Fecha 1| Fecha 2|
|:-----:|:--:|:-------:|:-----:|:-----:|
|lugar 1| Ind 1| Ind 1 | Ind 2| Ind 2|
|lugar 1| Ind 1| Ind 1 | Ind 2| Ind 2|

Otros ejemplos: 

+ Nombres de las columnas representan valores de los datos en lugar de nombres de variables -el nombre de un lugar por ejemplo-
+ Una columna contiene varias variables en lugar de una variable 
+ Una tabla contiene más de una unidad de observación
+ Las variables están contenidas en los renglones y columnas, en lugar de sólo columnas.
+ Los datos de una unidad observacional están dispersas en varios *data sets*

Usando `tidyr` se ve como sigue:

```{r echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}
library(tidyr)
messy <- data_frame(nombre=c("juan.perez.lopez","martha.lopez.benitez",
                             "jesus.ramirez.perez","jose.martinez.lopez",
                             "aurora.saldivar.salazar"),
                    genero_edad=c("m.35","f.23","m.30","m.25","f.33"),
                    time=c(1,3,4,5,6))

messy
```

Tendríamos que dejarlo *tidy*:

+ Separando el nombre
```{r echo=T, warning=F, error=F, message=F}
semi_messy <- messy %>% separate(col=nombre, into=c("nombre",
                                      "apellido_paterno",
                                      "apellido_materno"), 
                   sep="\\.")

semi_messy
```

+ Separando género y edad


```{r echo=T, warning=F, error=F, message=F}
clean <- semi_messy %>% separate(col=genero_edad, into=c("genero","edad"), 
                   sep="\\.")

clean
```

Otro ejemplo: ¿Qué está mal?

```{r echo=T, warning=F, error=F, message=F}
messy <- data_frame(pais=c(rep("Afganistan",4),
                           rep("Brazil",4),
                           rep("China",4)),
                    year=c(rep(1999,2),rep(2000,2),
                           rep(1999,2),rep(2000,2),
                           rep(1999,2),rep(2000,2)),
                    llave=c("casos","poblacion","casos","poblacion",
                          "casos","poblacion","casos","poblacion",
                          "casos","poblacion","casos","poblacion"),
                    valor=c(75,1300000,134,1400000,
                            10000,100000000,12000,120000000,
                            56000,150000000,60000,170000000))

messy
```

Lo deberíamos arreglar con: 

```{r echo=TRUE, error=FALSE, message=FALSE, warning=FALSE}
clean <- messy %>% spread(key=llave, value=valor, fill=NA)

clean
```

El último

```{r echo=TRUE, error=FALSE, message=FALSE, warning=FALSE}
stocks <- data_frame(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)

stocks

stocks %>% gather(stock, price, -time)
```


&nbsp;
  
####  G. Intermedios-Avanzados R
    
    i) Shiny
    ii) Simulación
    iii) Scrapping
    iv) Algoritmos de ML
    v) Creando un paquete
    vi) Paralelo
    vii) API´s
    
&nbsp;

####  H. Otras herramientas
    
    i) Git
    ii) Spark
    iii) SQLite, JS, C
    iv) Docker
    v) Bash programming, paralelo
    vi) AWS (Amazon cloud services)
    
Muchas gracias!!!

### Librerías

  + library(tidyverse)
  + library(readr)
  + library(data.table)
  + library(dplyr)
  + library(ggplot2)
  + library(ggthemes)
  + library(rmarkdown)
  + library(reticulate)
  + library(lubridate)
  + library(RColorBrewer)
  + library(tidyr)
  + library(tm)
  + library(qdap)
  + library(wordcloud)
  + library(stringdist)
  
15 librerías.

    
    
